<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>SRE API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;c++&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
              <a href="#" data-language-name="c++">Code examples</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The goal of SimpleRenderEngine (SRE) is to provide easy way to get started with graphics 
programming in 2D or 3D without a deep knowledge about the low-level graphics APIs like 
OpenGL, DirectX and Vulkan.</p>

<p>SRE currently depends on Simple Direct Layer 2.x (SDL2), SDL2-image, OpenGL Mathematics (GLM), and OpenGL 3.3 (or higher), and 
runs on both Windows, macOS and Linux.</p>

<p>The project is hosted here: <a href="https://github.com/mortennobel/SimpleRenderEngine">github.com/mortennobel/SimpleRenderEngine</a></p>

<h1 id="install">Install</h1>

<h2 id="prerequisites">Prerequisites:</h2>

<ul>
<li>Install C++ tool chain / IDE (such as Visual Studio 2015 or XCode)</li>
<li>Install CMake ( <a href="https://cmake.org/download/">cmake.org/download/</a> ). <strong>macOS:</strong> first lauch should be performed by right-clicking the .app and selecting open.</li>
</ul>

<h3 id="sdl-2-x-and-sdl-2-0-image">SDL 2.x and SDL 2.0 Image</h3>

<p>Simple DirectMedia Layer is a platform abstraction layer for game development. The 
abstraction makes both single platform and cross platform development easier. The project
has a simple C-interface.</p>

<p>Download <strong>development libraries (not runtime libraries!)</strong> from </p>

<ul>
<li><a href="https://www.libsdl.org/download-2.0.php">www.libsdl.org/download-2.0.php</a></li>
<li><a href="https://www.libsdl.org/projects/SDL_image/">www.libsdl.org/projects/SDL_image/</a></li>
</ul>

<p><strong>Windows:</strong> Extract the zip-files to any folder (e.g. Documents)</p>

<p><strong>macOS:</strong> Open dmg files and copy .frameworks to /Library/Framework</p>

<p>SDL documentation can be found here: <a href="http://wiki.libsdl.org/FrontPage">wiki.libsdl.org/FrontPage</a></p>

<h3 id="glm-opengl-mathematics">GLM (OpenGL Mathematics)</h3>

<p>GLM is a header-only C++ library for linear algebra such as vectors, matrices and quaternions.   </p>

<p>Download project from <a href="http://glm.g-truc.net">glm.g-truc.net</a> and extract to any folder. (e.g. Documents)</p>

<h3 id="glew-the-opengl-extension-wrangler-library">GLEW (The OpenGL Extension Wrangler Library)</h3>

<p><strong>(Windows only)</strong> Enable full OpenGL support for Windows. </p>

<p>Download the <strong>Windows 32-bit and 64-bit</strong> zip-file from http://glew.sourceforge.net/ and extract it to any folder (e.g. Documents).    </p>

<h2 id="download-and-setup-simplerenderengine">Download and setup SimpleRenderEngine</h2>

<p>Clone the repository from <a href="https://github.com/mortennobel/SimpleRenderEngine">github.com/mortennobel/SimpleRenderEngine</a> .</p>

<p>Configure the project using CMake ( / cmake-gui) to VisualStudio/XCode using the following settings:</p>

<p>Tips and comments:</p>

<ul>
<li>Windows : It is recommended that you build the project as <strong>32-bit</strong>.</li>
<li>It is important that you choose the correct </li>
<li>You need to click the configure whenever you have changed a setting. This ensures that all</li>
<li>Documentation for the CMake properties can be found in the cmake/FindXXX.cmake files</li>
<li>It is recommended to GLEW static library (<strong>glew32s.lib</strong>) for windows.</li>
<li>If you have old Visual Studio installation, you might need to change the settings of the Microsoft.Cpp.Win32.user (in the Property Manager)</li>
</ul>

<p><strong>Windows</strong></p>

<p>Notes:</p>

<ul>
<li>The SDL2_Library need to be the full path of both SDL2.lib and SDL2main.lib. Separated with
a semicolon.</li>
</ul>

<p><img title="CMake Mac" alt="alt text" src="images/cmake-windows.png" /></p>

<p><strong>Mac</strong></p>

<p><img title="CMake Mac" alt="alt text" src="images/cmake-mac.png" /></p>

<h1 id="resource-management">Resource management</h1>

<p>SimpleRenderEngine does not provide any automatically resource management. 
It is up the library user (the developer) to destroy any object that is allocated.</p>

<p>Generally objects can be created in three different ways:</p>

<ul>
<li><strong>Constructor</strong>: Object creation using constructor. If the objects are allocated on the heap (using new) they must also be explicit 
deleted when no longer used.</li>
<li><strong>createXXX()</strong>: Object pointers returned from createXXX member functions. These objects are created by
SimpleRenderEngine, but not referenced. These objects should be explicit deleted when
no longer used.</li>
<li><strong>getXXX()</strong>: Object pointers returned from getXXX member functions. The ownership of these objects are maintained by 
SimpleRenderEngine. These objects should not be deleted.</li>
</ul>

          <h1 id="simplerenderengine">SimpleRenderEngine</h1>

<p><code class="prettyprint">#include &quot;sre/Renderer.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="c1">// Example (hello-engine.cpp):
</span><span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
<span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_MAJOR_VERSION</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_MINOR_VERSION</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_PROFILE_MASK</span><span class="p">,</span> <span class="n">SDL_GL_CONTEXT_PROFILE_CORE</span><span class="p">);</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"Hello Engine"</span><span class="p">,</span><span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span><span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span><span class="mi">640</span><span class="p">,</span><span class="mi">480</span><span class="p">,</span><span class="n">SDL_WINDOW_OPENGL</span><span class="p">);</span>
<span class="n">Renderer</span> <span class="n">r</span><span class="p">{</span><span class="n">window</span><span class="p">};</span>
<span class="n">RenderPass</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">RenderPass</span><span class="o">::</span><span class="n">create</span><span class="p">().</span><span class="n">build</span><span class="p">();</span>
<span class="n">rp</span><span class="p">.</span><span class="n">drawLines</span><span class="p">({{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}});</span>
<span class="n">r</span><span class="p">.</span><span class="n">swapWindow</span><span class="p">();</span>
<span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="n">SDL_Quit</span><span class="p">();</span>
</code></pre>

<p>Maintains rendering context.
An object of Renderer must be created once after the SDL_Window has been initialized.
After initialization this object can be referenced using the static field Renderer::instance;</p>

<p>A renderer can use one or more renderpasses before calling swapWindow()</p>

          <h1 id="renderpass">RenderPass</h1>

<p>See Renderer.createRenderPass() for initialization.</p>

          <h1 id="sdlrenderer">SDLRenderer</h1>

<p><code class="prettyprint">#include &quot;sre/SDLRenderer.hpp&quot;</code></p>

<p>Simplifies SDL applications by abstracting away boilerplate code. </p>

<p>SDLRenderer is a pure helper-class, and no other class in the SimpleRenderEngine depends on it. </p>

<p>The class will create a window with a graphics context in the <code class="prettyprint">init()</code> member function.
The <code class="prettyprint">startEventLoop()</code> will start the event loop, which polls the event queue in the 
beginning of each frame (and providing callbacks to <code class="prettyprint">keyEvent</code> and <code class="prettyprint">mouseEvent</code>), followed by a <code class="prettyprint">frameUpdate(float)</code> and a <code class="prettyprint">frameRender(Renderer)</code>.</p>

<p>Example:</p>
<pre class="highlight plaintext"><code>#include "sre/SDLRenderer.hpp"

using namespace sre;
using namespace std;

int main() {
    SDLRenderer r;
    r.init();
    r.frameRender = [](){
        RenderPass rp = RenderPass::create().build();
        rp.drawLines({{-.5,-.5,0},{.5,.5,0},{-.5,.5,0},{.5,-.5,0}});
    };
    r.startEventLoop();

    return 0;
}
</code></pre>

          <h1 id="texture">Texture</h1>

<p><code class="prettyprint">#include &quot;sre/Texture.hpp&quot;</code></p>

<p>Represent a texture (uploaded to the GPU).
In general the width and the height of the texture should be power-of-two (e.g. 256 or 512).</p>

<p>Textures can be created from files (png). Alternative textures can be created using memory representation
of the texture in RGB/RGBA (one byte per color channel).</p>

<p>The Texture class also provides a white texture using the Texture::getWhiteTexture()</p>

<p>A texture object has the following properties:</p>

<ul>
<li>mipmaps enabled: Optimization, where the texture exists in downscaled versions. This does use more memory, but
in general gives faster texture sampling.</li>
<li>wrap texture coordinates: if enabled the texture is repeated when sampling out the 0.0 .. 1.0 values</li>
<li>filter sampling: if enabled the texture sampling will use interpolation to find the colors between pixel centers</li>
</ul>

          <h1 id="shader">Shader</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>

<p>Controls the appearance of the rendered objects.</p>

<p>The shader also controls depth test, depth write and blending.</p>

<p>There is the following premade shaders:
- Shader::getStandard()
   - Shades the mesh using the Phong light model, and uses the current light states and camera states as well as
     the color and texture parameters
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getUnlit()
   - Uses the camera states as well as the color and texture parameters to define the surface color
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getUnlitSprite()
   - Similar to getUnlit() but with no depth write
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getStandardParticles()
   - Similar to getUnlit() but with no depth write
   - Parameters:
     - tex (shared_ptr<Texture>) (default alpha sphere texture)</p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static ShaderBuilder create();</code></p>

<p>Creates a shader using the builder pattern. 
ShaderBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>ShaderBuilder&amp; withSource(const char* vertexShaderGLSL, const char* fragmentShaderGLSL);
ShaderBuilder&amp; withSourceStandard();
ShaderBuilder&amp; withSourceUnlit();
ShaderBuilder&amp; withSourceUnlitSprite();
ShaderBuilder&amp; withSourceStandardParticles();
ShaderBuilder&amp; withSourceDebugUV();
ShaderBuilder&amp; withSourceDebugNormals();
ShaderBuilder&amp; widthDepthTest(bool enable);
ShaderBuilder&amp; withDepthTest(bool enable);
ShaderBuilder&amp; withDepthWrite(bool enable);
ShaderBuilder&amp; withBlend(BlendType blendType);
std::shared_ptr&lt;Shader&gt; build();
</code></pre>

          <h1 id="mesh">Mesh</h1>

<p><code class="prettyprint">#include &quot;sre/Mesh.hpp&quot;</code></p>

<p>Represents a Mesh object.
A mesh is composed of a list of</p>

<ul>
<li>vertexPositions (vec3)</li>
<li>normals (vec3)</li>
<li>uvs (aka. texture coordinates) (vec2)</li>
</ul>

<p>A mesh also has a meshType, which can be either: 
 - MeshTopology::Points 
 - MeshTopology::Lines
 - MeshTopology::Triangles</p>

<p>The mesh is defined based on the order of vertices, when the indices is empty. 
Otherwise the indices is used to define the mesh. </p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static MeshBuilder create();</code></p>

<p>Creates a mesh using the builder pattern. 
MeshBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>MeshBuilder&amp; withSphere(int stacks = 16, int slices = 32, float radius = 1);
MeshBuilder&amp; withCube(float length = 1);
MeshBuilder&amp; withQuad();
MeshBuilder&amp; withPositions(const std::vector&lt;glm::vec3&gt; &amp;vertexPositions);
MeshBuilder&amp; withNormals(const std::vector&lt;glm::vec3&gt; &amp;normals);
MeshBuilder&amp; withUVs(const std::vector&lt;glm::vec4&gt; &amp;uvs);
MeshBuilder&amp; withColors(const std::vector&lt;glm::vec4&gt; &amp;colors);
MeshBuilder&amp; withParticleSizes(const std::vector&lt;float&gt; &amp;particleSize);
MeshBuilder&amp; withMeshTopology(MeshTopology meshTopology);
MeshBuilder&amp; withIndices(const std::vector&lt;uint16_t&gt; &amp;indices);
std::shared_ptr&lt;Mesh&gt; build();
</code></pre>

<h2 id="update">update</h2>

<p><code class="prettyprint">MeshBuilder update()</code></p>

<p>Updates a mesh using the builder pattern.
See Mesh::create().
Performance-wise it is more efficient to update an existing mesh than to create a new mesh.</p>

          <h1 id="camera">Camera</h1>

<p><code class="prettyprint">#include &quot;sre/Camera.hpp&quot;</code></p>

<p>The camera contains two important properties:
- <strong>view transform matrix</strong>: Contains information about location and orientation of the camera. This matrix will
transform geometry from world space to eye space.
- <strong>projection transform matrix</strong>: Contains information about the projection the camera uses (roughly equivalent to
which lens it uses). Generally this can either be perspective projection (with a field of view) or a orthographic
projection (without any perspective).</p>

<p>The camera also includes information about the viewport, which defines which part of the window is used for
rendering (default settings is the full window)</p>

<p>The default camera is positioned at (0,0,0) and looking down the negative z-axis. Everything inside the volume
between -1 to 1 is viewed.</p>

<p>Note that if the window size is resized the camera must explicit be updated using <code class="prettyprint">setViewport</code>,
<code class="prettyprint">setPerspectiveProjection</code>/<code class="prettyprint">setWindowCoordinates</code></p>

          <h1 id="light">Light</h1>

<p><code class="prettyprint">#include &quot;sre/Light.hpp&quot;</code></p>

<p>Contains information about a Light source</p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static LightBuilder create()</code></p>

<p>Creates a light using builder pattern. 
LightBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>LightBuilder&amp; withPointLight(glm::vec3 position);
LightBuilder&amp; withDirectionalLight(glm::vec3 direction);
LightBuilder&amp; withColor(glm::vec3 color);
LightBuilder&amp; withRange(float range);
Light build();
</code></pre>

          <h1 id="blendtype">BlendType</h1>

<p><code class="prettyprint">#include &quot;sre/Blendtype.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">BlendType</span> <span class="p">{</span>
    <span class="n">Disabled</span><span class="p">,</span>
    <span class="n">AlphaBlending</span><span class="p">,</span>
    <span class="n">AdditiveBlending</span>
<span class="p">};</span>
</code></pre>

<p>Enum which defines blending types. Currently support types of blending is:</p>

<ul>
<li>BlendType::Disabled - no blending</li>
<li>BlendType::AlphaBlending - Blends the surface with background based on alpha value (src alpha ,one minus src alpha)</li>
<li>BlendType::AdditiveBlending - Add light based on the alpha value (src alpha,one)</li>
</ul>

          <h1 id="lighttype">LightType</h1>

<p><code class="prettyprint">#include &quot;sre/LightType.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">LightType</span> <span class="p">{</span>
    <span class="n">Point</span><span class="p">,</span>
    <span class="n">Directional</span><span class="p">,</span>
    <span class="n">Unused</span>
<span class="p">};</span>
</code></pre>

<p>Defines the types of Light. Note ambient light is simply represented using a vec3 in the SimpleRenderEngine class.</p>

          <h1 id="meshtopology">MeshTopology</h1>

<p><code class="prettyprint">#include &quot;sre/MeshTopology.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">MeshTopology</span> <span class="p">{</span>
    <span class="n">Points</span><span class="p">,</span>
    <span class="n">Lines</span><span class="p">,</span>
    <span class="n">LineStrip</span><span class="p">,</span>
    <span class="n">Triangles</span><span class="p">,</span>
    <span class="n">TriangleStrip</span><span class="p">,</span>
    <span class="n">TriangleFan</span>
<span class="p">};</span>
</code></pre>

<p>Mesh topology used to define the type of mesh</p>

          <h1 id="uniform">Uniform</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">struct</span> <span class="n">Uniform</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">UniformType</span> <span class="n">type</span><span class="p">;</span>
    <span class="c1">// 1 means not array
</span>    <span class="kt">int</span> <span class="n">arraySize</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>

<p>Defines the structure of a shader uniform</p>

          <h1 id="uniformtype">UniformType</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">UniformType</span> <span class="p">{</span>
    <span class="n">Int</span><span class="p">,</span>
    <span class="n">Float</span><span class="p">,</span>
    <span class="n">Mat3</span><span class="p">,</span>
    <span class="n">Mat4</span><span class="p">,</span>
    <span class="n">Vec4</span><span class="p">,</span>
    <span class="n">Texture</span><span class="p">,</span>
    <span class="n">TextureCube</span><span class="p">,</span>
    <span class="n">Invalid</span>
<span class="p">};</span>
</code></pre>

<p>Defines variable types for shader uniforms</p>

          <h1 id="renderstats">RenderStats</h1>

<p><code class="prettyprint">#include &quot;sre/RenderStats.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">struct</span> <span class="n">RenderStats</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">frame</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">meshCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">meshBytes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">textureCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">textureBytes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">shaderCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">drawCalls</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesShader</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesMaterial</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesMesh</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>

<p>Contains information about the last frame</p>

          <h1 id="imgui_sre">ImGui_SRE</h1>

<p><code class="prettyprint">#include &quot;sre/imgui_sre.hpp&quot;</code></p>

<p>The ImGUI library is included in SRE.</p>

<p>The Github project: <a href="https://github.com/ocornut/imgui">github.com/ocornut/imgui</a></p>

<p>Documentation: </p>

<ul>
<li><a href="https://github.com/ocornut/imgui/blob/master/imgui.h">github.com/ocornut/imgui/blob/master/imgui.h</a></li>
<li><a href="https://github.com/ocornut/imgui/blob/master/imgui_demo.cpp">github.com/ocornut/imgui/blob/master/imgui_demo.cpp</a></li>
</ul>

<h2 id="imgui_sre_processevent">ImGui_SRE_ProcessEvent</h2>

<p><code class="prettyprint">bool        ImGui_SRE_ProcessEvent(SDL_Event *event);</code></p>

<p>ImGui_SRE_ProcessEvent must be invoked in the beginning of each frame before any other ImGui calls to capture events from SDL.</p>
<pre class="highlight cpp"><code>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit</span><span class="p">){</span>
        <span class="c1">//Handle events on queue
</span>        <span class="k">while</span><span class="p">(</span> <span class="n">SDL_PollEvent</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">e</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ImGui_SRE_ProcessEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_QUIT</span><span class="p">)</span>
                <span class="n">quit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">renderPass</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">createRenderPass</span><span class="p">()</span>
                <span class="p">.</span><span class="n">withCamera</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
                <span class="p">.</span><span class="n">withWorldLights</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worldLights</span><span class="p">)</span>
                <span class="p">.</span><span class="n">withClearColor</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">})</span>
                <span class="p">.</span><span class="n">build</span><span class="p">();</span>

        <span class="c1">// draw geometry
</span>        <span class="n">renderPass</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">modelMatrix</span><span class="p">,</span> <span class="n">materialPointer</span><span class="p">);</span>

        <span class="c1">// draw gui
</span>        <span class="n">ImGui</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="s">"Dear ImGui says hello."</span><span class="p">);</span>

        <span class="n">r</span><span class="p">.</span><span class="n">swapWindow</span><span class="p">();</span>
        <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>

</code></pre>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c++">Code examples</a>
          </div>
      </div>
    </div>
  </body>
</html>
